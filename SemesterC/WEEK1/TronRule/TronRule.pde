/*

CELLULAR AUTOMATA: TRON RULE
[Margolus-neighborhood block cellular automata derivative]

The rectilinear shapes generated by the Tron rule.
In the "Tron" rule, the transition function leaves each block 
unchanged except when all four of its cells have the same state, 
in which case their states are all reversed. Running this rule 
from initial conditions in the form of a rectangle of live cells, 
or from similar simple straight-edged shapes, leads to complex 
rectilinear patterns. Toffoli and Margolus also suggest that 
this rule can be used to implement a local synchronization rule 
that allows any Margolus-neighborhood block cellular automaton 
to be simulated using an asynchronous cellular automaton. 

In this simulation, each cell of an asynchronous automaton stores 
both a state for the simulated automaton and a second bit 
representing the parity of a timestamp for that cell; 
therefore, the resulting asynchronous automaton has twice as many 
states as the automaton it simulates. The timestamps are constrained 
to differ by at most one between adjacent cells, and any block of four 
cells whose timestamps all have the correct parity may be updated according 
to the block rule being simulated. When an update of this type is performed, 
the timestamp parities should also be updated according to the Tron rule, 
which necessarily preserves the constraint on adjacent timestamps. 

By performing local updates in this way, the evolution of each cell in 
the asynchronous automaton is identical to its evolution in the synchronous 
block automaton being simulated.


Tron Rule is invertible. Population is variable.

Rule is invariant to: rotation by 90°, rotation by 180°, horizontal flip, vertical flip,
negation of cells, vertical flip with negation, horizontal flip with negation.

Rule is self-dual and has periodic vacuum with period 2.

0,14,13,12,11,10,9,8,7,6,5,4,3,2,1,15

Phase 0:
 
 0 0 
 0 0 
 
Phase 1:

 1 1
 1 1

TRON SEQUENCE:

{ 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0 }

CRITTERS SEQUENCE:

{ 15, 14, 13, 3, 11, 5, 6, 1, 7, 9, 10, 2, 12, 4, 8, 0 }

TODO:

[x] shift pixel matrix instead of values

REFERENCES:
https://en.wikipedia.org/wiki/Block_cellular_automaton
https://en.wikipedia.org/wiki/Reversible_cellular_automaton !!!! [a reversable CAs]
https://github.com/KalebKE/CAExplorer/tree/master/cellularAutomata/rules
http://cell-auto.com/neighbourhood/margolus/
http://psoup.math.wisc.edu/mcell/rullex_marg.html

@author Vladimir V KUCHINOV
@email  helloworld@vkuchinov.co.uk

*/

import java.lang.StringBuilder;
import java.util.Arrays;

int ratio = 4;
PImage initialState;
PImage currentState;

int[][] states;
Margolus CA;

void setup(){
 
    initialState = loadImage("data/stateE.png");
    size(initialState.width * ratio , initialState.height * ratio, P2D);
    
    states = new int[initialState.width][initialState.height];
    
    for(int h = 0; h < initialState.height; h++){
     for(int w = 0; w < initialState.width; w++){
      
       color c = initialState.get(w, h);
       if(c == -16777216) { states[w][h] = 0; } else { states[w][h] = 1; }
       
     }
    } 
   
    CA = new Margolus(new int[]{ 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0 }, initialState.width, initialState.height);

    currentState = createImage(width, height, RGB);
    currentState.loadPixels();
    for (int i = 0; i < currentState.pixels.length; i++) { currentState.pixels[i] = color(0, 0, 0);  }
    currentState.updatePixels();
    
}

void draw(){
 
  if(frameCount % 12 == 0) {  CA.setMatrix(states); CA.permutate(states);   }
  renderStates();
  
}


void renderStates(){

  for(int h = 0; h < initialState.height; h++){
     for(int w = 0; w < initialState.width; w++){
      
        if(states[w][h] == 0){

          setPixel(w, h, color(0, 0, 0));
         
        } 
        else{
        
          setPixel(w, h, color(0, 255, 0));  
        
        }

     }
    } 
    
  
  image(currentState, 0, 0, width, height); 

}

void setPixel(int x_, int y_, color c_){
  
    for(int i = 0; i < ratio; i++){
      for(int j = 0; j < ratio; j++){
        
          currentState.set(x_ * ratio + i, y_ * ratio + j, c_);
        
      }
    }
  
  
}
